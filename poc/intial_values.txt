metricas = [{
nome:"Número de defeitos abertos em qualquer dia de liberação = Número de relatos de defeitos abertos",
objetivo:"Identificar quantos defeitos foram abertos em determinado dia de liberação do sistema (cada dia deve ser contado)",
pergunta: "Quantos defeitos têm em aberto?",
base_medicao:"Contagem de números de defeitos em aberto",
suposicoes:"A equipe a cada dia conta quantos defeitos foram abertos e quantos desses defeitos foram fechados.",
tendencia_experada:"A medida que vai se aproximando o final do projeto, o número de defeitos em aberto tende a zero.",
quando_utilizar:"Quando a equipe deseja monitorar a quantidade de defeitos em aberto para tentar fechá-los antes do termino do projeto.",
quando_parar:"Ao finalizar o projeto",
manipulacao:"Uma das formas de apresentação é através de um gráfico",
cuidados:" ",
coleta:"Execução",
forma:"",
importancia_metodos_ageis:"",
classificacao_1:"Direta",
classificacao_2:"Qualidade do produto",
classificacao_3:"Quantitativa, Objetiva, Acompanhamento"
},{
nome:"Tempo de (retorno) recuperação do defeito",
objetivo:"Definir o tempo de recuperação do defeito",
pergunta: "Qual o tempo de recuperação do defeito?",
base_medicao:"Tempo de recuperação do defeito = (Tempo gasto para corrigir o defeito) / (Tempo planejado para corrigir o defeito)",
suposicoes:"Quando o defeito é levantado pela primeira vez, a equipe de teste precisa avaliar o impacto e fornecer o gerenciamento de testes com um target para a correção dos dados. Este seria o tempo estimado necessário para corrigir o defeito. Uma vez que a correção seja entregue com sucesso, o tempo real para corrigir é então calculado baseado nos “dias trabalhados”.",
tendencia_experada:"O tempo gasto deve se aproximar do tempo planejado",
quando_utilizar:"Para identificar o tempo despendido na recuperação do defeito.",
quando_parar:"Quando todos os defeitos identificados tiverem sido corrigidos",
manipulacao:"Se o tempo de retorno do defeito é menor que 1, em seguida, as estimativas precisam ser revisitadas.  Target: <1",
cuidados:"Tempo de recuperação do defeito é definido como o Tempo entre quando o defeito foi levantado pela primeira vez e quando o defeito é fixado para reteste  - Tempo de retorno do defeito é calculado em “dias trabalhados” como unidade padrão de medida",
coleta:"Execução",
forma:"",
importancia_metodos_ageis:"",
classificacao_1:"Indireta",
classificacao_2:"Desempenho do processo",
classificacao_3:"Quantitativa, Objetiva, Acompanhamento"
},{
nome:"Tempo gasto para corrigir o defeito",
objetivo:"Medir o tempo gasto com a correção do defeito",
pergunta: "Qual o tempo gasto com a correção do defeito?",
base_medicao:"Tempo total de horas gastas com a correção do defeito",
suposicoes:"A equipe verifica o tempo gasto com a correção de defeitos",
tendencia_experada:"Conforme a quantidade de falhas reportadas diminui, o tempo gasto com a correção de um defeito também deve diminuir",
quando_utilizar:"Quando a equipe pretende identificar o tempo utilizado para a correção do defeitos",
quando_parar:"Quando não houver mais defeitos para serem corrigidos",
manipulacao:"Coletar hora do início e hora de encerramento do projeto",
cuidados:" ",
coleta:"Execução",
forma:"",
importancia_metodos_ageis:"",
classificacao_1:"Direta",
classificacao_2:"Desempenho do processo",
classificacao_3:"Quantitativa, Objetiva, Acompanhamento"
},{
nome:"Tempo planejado para corrigir o defeito",
objetivo:"Medir o tempo planejado para correção do defeito",
pergunta: "Qual o tempo planejado para correção do defeito?",
base_medicao:"Tempo planejado para correção do defeito",
suposicoes:"A equipe planejou o tempo necessário para a correção do defeito e delimitou o tempo necessário para o cumprimento.",
tendencia_experada:"Corrigir os defeitos no tempo e forma planejados",
quando_utilizar:"Quando se deseja aumentar a eficiencia da equipe durante o projeto, diminuindo assim gargalos e mantendo o cronograma em dia.",
quando_parar:"Quando não houver mais defeitos para serem corrigidos",
manipulacao:"O lider deve verificar o tempo planejado.",
cuidados:" ",
coleta:"Execução",
forma:"",
importancia_metodos_ageis:"",
classificacao_1:"Direta",
classificacao_2:"Desempenho do processo",
classificacao_3:"Quantitativa, Objetiva, Acompanhamento"
},{
nome:"Total de defeitos encontrados nos testes = Número de defeito cometidos por uma equipe ou por um programador = Total de defeitos encontrados pelo cliente = Número de defeitos durante a revisão da avaliação",
objetivo:"Identificar a quantidade total de defeitos encontrados no projeto com a execução de testes",
pergunta: "Qual o número de defeitos encontrados?",
base_medicao:"Contagem de números de defeitos encontrados com a execução dos testes",
suposicoes:"A equipe identifica a quantidade de defeitos durante a execução dos testes",
tendencia_experada:"A quantidade de defeitos encontrados na fase de teste deve diminuir conforme o processo é melhorado",
quando_utilizar:"Para monitorar a atividade de teste de software e informar a quantidade total de números de defeitos identificados",
quando_parar:"Ao final de cada iteração ou ao final do projeto",
manipulacao:"Essa métrica pode ser manipulada através da execução de procedimentos e casos de teste.",
cuidados:"Esta métrica pode ser aplicada ao final de cada iteração, ou ao final do projeto. Ela também pode ser aplicada por módulo ou por nível de teste.",
coleta:"Execução",
forma:"",
importancia_metodos_ageis:"",
classificacao_1:"Direta",
classificacao_2:"Qualidade do produto",
classificacao_3:"Quantitativa, Objetiva, Acompanhamento"
},{
nome:"Defeitos resolvidos",
objetivo:"Identificar a quantidade de defeitos resolvidos",
pergunta: "Qual a quantidade de defeitos resolvidos?",
base_medicao:"(Número de defeitos corrigidos * 100) / Número de casos de teste executados.",
suposicoes:"A equipe verifica o esforço em corrigir os defeitos identificados em relação à execução dos casos de teste",
tendencia_experada:"Resolver todos os defeitos encontrados",
quando_utilizar:"Quando a equipe deseja saber quantos defeitos foram resolvidos",
quando_parar:"Quando todos os defeitos forem resolvidos",
manipulacao:" ",
cuidados:"Esta métrica pode ser aplicada ao final de cada iteração, ou ao final do projeto. Ela também pode ser aplicada por módulo ou por nível de teste.",
coleta:"Execução",
forma:"",
importancia_metodos_ageis:"",
classificacao_1:"Indireta",
classificacao_2:"Qualidade do produto",
classificacao_3:"Quantitativa, Objetiva, Acompanhamento"
},{
nome:"Esforço gasto para correção de defeitos",
objetivo:"Verificar o esforço gasto para a correção de defeitos",
pergunta: "Qual o esforço gasto para a correção de defeitos?",
base_medicao:"Quantidade total de horas gastas para corrigir um defeito",
suposicoes:" ",
tendencia_experada:"Diminuição do esforço envolvido na correção de um defeito.",
quando_utilizar:"Quando se deseja monitorar a eficiencia da equipe e dos casos de teste planejados, com relação a quantidade de defeitos existentes.",
quando_parar:"Durante a etapa final do projeto.",
manipulacao:" ",
cuidados:" ",
coleta:"Execução",
forma:"",
importancia_metodos_ageis:"",
classificacao_1:"Indireta",
classificacao_2:"Desempenho do processo",
classificacao_3:"Quantitativa, Objetiva, Acompanhamento"
},{
nome:"Densidade de defeitos = Densidade de erros = Densidade de erro por iteração",
objetivo:"Identificar a quantidade de falhas no código",
pergunta: "Qual a quantidade de falhas no código que foram reportados?",
base_medicao:"Número de falhas / Número de linhas de código",
suposicoes:"É necessário medir o tamanho do código e o número de falhas (relatados no final da iteração)",
tendencia_experada:"Diminuir a quantidade de falhas no código",
quando_utilizar:"Quando o desenvolvedor quer verificar a quantidade de falhas em relação ao código produzido",
quando_parar:"Ao final de cada iteração",
manipulacao:"Verificação do código",
cuidados:"A densidade da falha é a relação do tamanho do código e o número de falhas por iteração. Medir o número de falhas relatadas no final da iteração (na reunião de revisão da iteração) e em um período fixo após o lançamento.",
coleta:"Execução",
forma:"",
importancia_metodos_ageis:"",
classificacao_1:"Indireta",
classificacao_2:"Qualidade do produto",
classificacao_3:"Quantitativa, Objetiva, Acompanhamento"
},{
nome:"Número de casos de teste automatizados",
objetivo:"Verificar a quantidade de casos de teste automatizados",
pergunta: "Qual a quantidade de casos de teste automatiza,dos?",
base_medicao:"Quantidade de casos de teste automatizado.",
suposicoes:"A equipe deseja monitorar a quantidade de testes automatizados que estão sendo criados durante o projeto.",
tendencia_experada:"A taxa de automação deve se aproximar da quantidade de casos de teste, para ter uma alta taxa de automação.",
quando_utilizar:"Para medir o esforço da equipe na elaboração de casos de teste automatizados",
quando_parar:"Ao fim do projeto",
manipulacao:"Utilização de ferramentas específicas para criação e execução de testes .",
cuidados:" ",
coleta:"Planejamento",
forma:"",
importancia_metodos_ageis:"",
classificacao_1:"Direta",
classificacao_2:"Qualidade do produto",
classificacao_3:"Quantitativa, Objetiva, Acompanhamento"
},{
nome:"Número de casos de teste manuais",
objetivo:"Verificar a quantidade de casos de teste manuais",
pergunta: "Qual a quantidade de casos de teste manu,ais?",
base_medicao:"Quantidade de casos de teste manuais",
suposicoes:"A equipe deseja monitorar a quantidade de testes manuais que estão sendo criados durante o projeto.",
tendencia_experada:"A quantidade de casos de teste manuais deve, com o tempo, chegar a 0, pois o objetivo é que tudo esteja automatizado.",
quando_utilizar:"Para medir o esforço da equipe na elaboração de casos de teste manuais",
quando_parar:"Ao fim do projeto",
manipulacao:"Criação e execução de testes pelos membros da equipe.",
cuidados:" ",
coleta:"Planejamento",
forma:"",
importancia_metodos_ageis:"",
classificacao_1:"Direta",
classificacao_2:"Qualidade do produto",
classificacao_3:"Quantitativa, Objetiva, Acompanhamento"
},{
nome:"Número de testes de aceitação por história",
objetivo:"Medir a quantidade de testes de aceitação por estória ou funcionalidade do sistema.",
pergunta: "Qual a contagem de testes de aceitação por estória do projeto?",
base_medicao:"Para que uma funcionalidade do sistema esteja satisfeita, uma história de usuário só pode ser considerada acabada quando seus testes de aceitação executarem completamente",
suposicoes:"A equipe verifica a quantidade de testes de aceitação por funcionalidade ou estória",
tendencia_experada:"Aumentar a quantidade de histórias de usuários atendidas",
quando_utilizar:"Durante a escrita do teste de aceitação para verificar se determinada funcionalidade contempla as expectativas dos clientes.",
quando_parar:"Uma história de usuário só pode ser considerada acabada quando seus testes de aceitação executarem completamente",
manipulacao:"Verificar se o sistema atende determinada funcionalidade associada à história de usuário",
cuidados:" ",
coleta:"Planejamento",
forma:"",
importancia_metodos_ageis:"",
classificacao_1:"Direta",
classificacao_2:"Qualidade do produto",
classificacao_3:"Quantitativa, Objetiva, Acompanhamento"
},{
nome:"Tempo para corrigir testes (Time to fix tests)",
objetivo:"Monitorar o tempo investido na correção de teste a fim de diminuir esse tempo e manter a eficiência",
pergunta: "Qual o tempo gasto na correção dos testes?",
base_medicao:"Tempo total = hora final - hora inicial",
suposicoes:"Uma suposição: o caso de teste foi elaborado erroneamente e a falha foi identificada no momento da execução do teste",
tendencia_experada:"Diminuir o tempo de correção de testes",
quando_utilizar:"Quando for identificada falhas nos casos de teste",
quando_parar:"Quando não houver mais falhas nos casos de teste",
manipulacao:"Revisão de casos de teste antes e depois da execução",
cuidados:" ",
coleta:"Execução",
forma:"",
importancia_metodos_ageis:"",
classificacao_1:"Direta",
classificacao_2:"Cronograma e progresso",
classificacao_3:"Quantitativa, Objetiva, Acompanhamento"
},{
nome:"Tempo de conclusão do projeto = hora do início ao encerramento do projeto = Esforço em horas",
objetivo:"Definir o tempo gasto com projeto",
pergunta: "Qual o tempo gasto para concluir o projeto?",
base_medicao:"Quantidade total de horas gastas com o projeto",
suposicoes:"A equipe verifica o tempo despendido para a conclusão do projeto.",
tendencia_experada:"Diminuir o esforço gasto no desenvolvimento do projeto",
quando_utilizar:"Quando a equipe pretende identificar o tempo total utilizado no projeto",
quando_parar:"Ao final do projeto",
manipulacao:"Coletar hora do início e hora de encerramento do projeto",
cuidados:" ",
coleta:"Execução",
forma:"",
importancia_metodos_ageis:"",
classificacao_1:"Direta",
classificacao_2:"Cronograma e progresso",
classificacao_3:"Quantitativa, Objetiva, Acompanhamento"
},{
nome:"Tarefas concluídas dentro do tempo",
objetivo:"Identificar tarefas que foram realizadas dentro do tempo previsto",
pergunta: "As tarefas planejadas estão sendo concluídas dentro do tempo esperado?",
base_medicao:"Quantidade Total de Tarefas = Tarefas Planejadas - Tarefas Realizadas",
suposicoes:"A equipe planejou as tarefas a serem realizadas em determinada iteração. A equipe delimitou o tempo necessário para o cumprimento das tarefas.",
tendencia_experada:"Realizar todas as tarefas e entregar o produto no prazo determinado",
quando_utilizar:"Quando pretende-se medir o esforço em horas para cada tarefa, buscando a diminuição do tempo gasto em cada atividade.",
quando_parar:"Quando todas as tarefas planejadas são realizadas",
manipulacao:"Essa métrica pode ser manipulada através da verificação das tarefas planejadas e realizadas",
cuidados:" ",
coleta:"Execução",
forma:"",
importancia_metodos_ageis:"",
classificacao_1:"Direta",
classificacao_2:"Cronograma e progresso",
classificacao_3:"Quantitativa, Objetiva, Acompanhamento"
},{
nome:"Pontos de história concluídos por iteração = Tamanho de histórias de usuários = Tamanho (em pontos de história) de cada história de usuário no Product Backlog = Quantidade de trabalho realizado em cada iteração (em pontos de histórias) = Estimativa de histórias de usuário (tamanho)",
objetivo:"Verificar o total de pontos de histórias de usuário reportados na iteração",
pergunta: "Qual a quantidade de pontos de história concluídos na iteração?",
base_medicao:"Para estimar os pontos de cada história, você atribui 1 ponto para o teste mais simples de todos e pontua os demais a partir dele. (Complexidade x Esforço)  Total de pontos estimados pela equipe para todas as histórias da iteração",
suposicoes:"Estimativa de histórias de usuário quando são precisas indicam que a equipe conseguiu alcançar o entendimento da necessidade do Product Owner e isso implica em uma maior produtividade e eficiência. E maior eficiência implica na definição da velocidade com maior precisão.",
tendencia_experada:"Aumentar a quantidade de pontos de história realizados a cada iteração",
quando_utilizar:"Quando a equipe pretende identificar a quantidade de trabalho gasto na iteração através de pontos de história",
quando_parar:"ao termino de cada iteração",
manipulacao:"Verificar os pontos estimados e conferir o que realmente foi alcançado",
cuidados:"Pontos de história serve para ter uma referência de esforço para concluir o projeto e o número de pontos executados pela equipe em uma iteração é chamado de velocidade.",
coleta:"Execução",
forma:"",
importancia_metodos_ageis:"",
classificacao_1:"Direta",
classificacao_2:"Cronograma e progresso",
classificacao_3:"Quantitativa, Objetiva, Acompanhamento"
},{
nome:"Tamanho do backlog",
objetivo:"Medir o tamanho do escopo de teste do projeto",
pergunta: "Qual ,a quantidade de testes planejados para o projeto?",
base_medicao:" ",
suposicoes:"A equipe de testes planejou as fases de teste de cada iteração do projeto.",
tendencia_experada:"Exito na aplicação do teste de software.",
quando_utilizar:"Quando se deseja ter conhecimento se a quantidade de testes planejados foi suficiente para dar total cobertura ao projeto.",
quando_parar:"Ao fim do projeto",
manipulacao:"Os testadores verificam a quantidade de testes planejados com o escopo do projeto e concluem se faltam testes ou não.",
cuidados:" ",
coleta:"Execução",
forma:"",
importancia_metodos_ageis:"",
classificacao_1:"Indireta",
classificacao_2:"Desempenho do processo",
classificacao_3:"Quantitativa, Objetiva, Acompanhamento"
},{
nome:"Histórias de usuário não verificadas",
objetivo:"Identificar estórias não realizadas",
pergunta: "Quantas e quais estórias de usuário nao foram realizadas ?",
base_medicao:"Quantidade de tarefas não relizadas",
suposicoes:"A equipe planejou a realização de uma atividade. A equipe concluiu a iteração.",
tendencia_experada:"Entregar as atividades planejadas no tempo e forma planejados",
quando_utilizar:"Quando existe atividades não realizadas em uma iteração. Quando se deseja medir a produtividade de uma equipe.",
quando_parar:"Quando não há atividades em atraso ou não realizadas.",
manipulacao:"O lider deve fazer a verificação da realização das tarefas incumbidas a equipe.",
cuidados:" ",
coleta:"Execução",
forma:"",
importancia_metodos_ageis:"",
classificacao_1:"Direta",
classificacao_2:"Qualidade do produto",
classificacao_3:"Quantitativa, Objetiva, Acompanhamento"
},{
nome:"Quantidades de trabalho restante (em horas) para cada tarefa da iteração = Estimativa da quantidade de trabalho restante que precisa ser feito",
objetivo:"Estimar o tempo necessário para completar as demais atividades",
pergunta: "Qual a quantidade de tempo restante para o termino da tarefa?",
base_medicao:"Registro de horas de trabalho restante em cada tarefa no Sprint Backlog",
suposicoes:"A equipe planejou a sprint e delimitou um tempo para a realização de cada tarefa.",
tendencia_experada:"Fazer estimativas mais aproximadas",
quando_utilizar:"Quando se quer controlar o tempo proposto para cada tarefa e verificar seu cumprimento de forma eficiente.",
quando_parar:"Ao termino do Sprint",
manipulacao:"A estimativa do trabalho que ainda resta a ser feito no Sprint é calculada diariamente e colocada em um gráfico, resultando em um Sprint Burndown Chart.",
cuidados:" ",
coleta:"Execução",
forma:"",
importancia_metodos_ageis:"",
classificacao_1:"Direta",
classificacao_2:"Desempenho do processo",
classificacao_3:"Quantitativa, Objetiva, Acompanhamento"
},{
nome:"Quantidades de trabalho gasto (em horas) para cada tarefa na iteração",
objetivo:"Verificar o andamento das tarefas",
pergunta: "Qual a quantidade de tempo gasto em cada tarefa?",
base_medicao:"Registro de horas gastas em cada tarefa no Sprint Backlog",
suposicoes:"A equipe realiza as tarefas e regista o tempo gasto em cada uma delas.",
tendencia_experada:"Fazer estimativas mais aproximadas",
quando_utilizar:"Quando a equipe quer verificar a quantidade de trabalho realizado",
quando_parar:"Ao termino do Sprint",
manipulacao:"A estimativa do trabalho realizado no Sprint é calculada diariamente e colocada em um gráfico, resultando em um Sprint Burndown Chart",
cuidados:" ",
coleta:"Execução",
forma:"",
importancia_metodos_ageis:"",
classificacao_1:"Direta",
classificacao_2:"Desempenho do processo",
classificacao_3:"Quantitativa, Objetiva, Acompanhamento"
},{
nome:"Número de problemas reportados nas reuniões diárias",
objetivo:"Identificar os impedimentos para a execução das tarefas para soluciona-los e reduzi-los.",
pergunta: "Quantos problemas aparecem nas reuniões diárias?",
base_medicao:"Registro da quantidade de problemas que aparecem nas reuniões diárias",
suposicoes:"A equipe se reune diariamente.",
tendencia_experada:"A quantidade de problemas reportados tende a zero ao final da iteração.",
quando_utilizar:"Durante todo o projeto.",
quando_parar:"Ao final do projeto.",
manipulacao:"O lider deve marcar um horario e local para a equipe reunir-se diariamente e expor problemas e outras questoes relacionada ao projeto.",
cuidados:" ",
coleta:"Execução",
forma:"",
importancia_metodos_ageis:"",
classificacao_1:"Direta",
classificacao_2:"Desempenho do processo",
classificacao_3:"Quantitativa, Objetiva, Acompanhamento"
},{
nome:"Tarefas executadas",
objetivo:"Identificar a quantidade de tarefas executadas",
pergunta: "Quantas tarefas foram executadas em rel,ação a quantidade total de tarefas?",
base_medicao:"Tarefas executadas/Total de tarefas",
suposicoes:"A equipe planejou a iteração e o projeto. A equipe delimitou a quantidade de tarefas a serem realizadas.",
tendencia_experada:"Cumprimeiro de todas as tarefas planejadas.",
quando_utilizar:"Quando se deseja manter o curso de produção planejado para a etapa do projeto, evitando atrasos.",
quando_parar:"Ao executar todas as tarefas planejadas",
manipulacao:" ",
cuidados:" ",
coleta:"Execução",
forma:"",
importancia_metodos_ageis:"",
classificacao_1:"Indireta",
classificacao_2:"Desempenho do processo",
classificacao_3:"Quantitativa, Objetiva, Acompanhamento"
},{
nome:"Esforço gasto em testes",
objetivo:"Verificar o esforço gasto com a execução dos testes",
pergunta: "Qual o esforço gasto na execução dos testes?",
base_medicao:"Esforço gasto em testes = qtde de testes /tempo de execução dos testes",
suposicoes:"A equipe planejou os testes",
tendencia_experada:"Verificar se existem gargalos na execução dos testes",
quando_utilizar:"Quando se deseja medir o esforço gasto na execução de testes",
quando_parar:"Ao final da atividade de teste",
manipulacao:"O líder monitora a quantidade de testes planejados e o tempo gasto na execução.",
cuidados:"Esta métrica pode ser aplicada ao final de cada iteração, ou ao final do projeto. Ela também pode ser aplicada por módulo ou por nível de teste.",
coleta:"Execução",
forma:"",
importancia_metodos_ageis:"",
classificacao_1:"Indireta",
classificacao_2:"Desempenho do processo",
classificacao_3:"Quantitativa, Objetiva, Acompanhamento"
},{
nome:"Eficiência na remoção de defeitos",
objetivo:"Verificar a eficiência na remoção de defeitos",
pergunta: "Qual a eficiência analisada na correção dos defeitos relatad,os?",
base_medicao:"Quantidade total de horas gastas para remover de defetos",
suposicoes:"A equipe planejou os testes, executou e reportou defeitos",
tendencia_experada:"Aumentar a quantidade de defeitos removidos",
quando_utilizar:"Quando se deseja verificar se os defeitos foram removidos de forma eficiente",
quando_parar:"Quando todos os defeitos encontrados forem removidos de forma eficiente",
manipulacao:" ",
cuidados:" ",
coleta:"Execução",
forma:"",
importancia_metodos_ageis:"",
classificacao_1:"Indireta",
classificacao_2:"Desempenho do processo",
classificacao_3:"Quantitativa, Objetiva, Acompanhamento"
},{
nome:"Estimativa de histórias de usuário (tempo)",
objetivo:"Verificar o total de horas reportadas como gastas para implementar as histórias da iteração",
pergunta: "Qual a estimativa em horas de histórias de usuário?",
base_medicao:"Total de horas estimadas pela equipe para todas as histórias da iteração",
suposicoes:" ",
tendencia_experada:"Estimativa de histórias de usuário quando são precisas indicam que a equipe conseguiu alcançar o entendimento da necessidade do Product Owner e isso implica em uma maior produtividade e eficiência. E maior eficiência implica na definição da velocidade com maior precisão.",
quando_utilizar:" ",
quando_parar:"Ao final de cada iteração",
manipulacao:"Verificar a quantidade de horas estimadas e conferir as que realmente foram gastas",
cuidados:" ",
coleta:"Execução",
forma:"",
importancia_metodos_ageis:"",
classificacao_1:"Direta",
classificacao_2:"Cronograma e progresso",
classificacao_3:"Quantitativa, Objetiva, Acompanhamento"
},{
nome:"Precisão da estimativa de teste (tempo para construir)",
objetivo:"Verificar se o tempo de construção do processo de teste está adequado.",
pergunta: "Qual a precisão da estimativa de te,mpo de construção de teste?",
base_medicao:"Tempo planejado/Tempo utilizado",
suposicoes:"A equipe deseja saber se o tempo planejado para construir o sistema, está adequado ao processo de teste.",
tendencia_experada:"O tempo utilizado deve se aproximar do tempo planejado",
quando_utilizar:" ",
quando_parar:" ",
manipulacao:"Se o tempo de estimativa de teste é menor que 1, em seguida, as estimativas precisam ser revisitadas.  Target: <1",
cuidados:" ",
coleta:"Execução",
forma:"",
importancia_metodos_ageis:"",
classificacao_1:"Indireta",
classificacao_2:"Desempenho do processo",
classificacao_3:"Qualitativa, Subjetiva, Acompanhamento"
},{
nome:"Percentual de funções que seguem os requisitos (Estórias aprovadas)",
objetivo:"Identificar o percentual de funcionalidades que estão de acordo com os requisitos",
pergunta: "Qual o percentual de funcionalidades de acordo com os requisitos?",
base_medicao:"(Funções de acordo com os requisitos/ Total de funções requeridas) * 100",
suposicoes:"A equipe implementa as funcionalidades no sistema e verifica quais realmente estão de acordo com os requisitos do cliente",
tendencia_experada:"Fazer com que todas as funcionalidades exigidas pelo cliente sejam implementadas e que outras funcionalidades em desacordo, sejam removidas",
quando_utilizar:"Quando a equipe deseja verificar se o que foi desenvolvido está de acordo com os requisitos planejados",
quando_parar:"Ao final do projeto",
manipulacao:" ",
cuidados:" ",
coleta:"Execução",
forma:"",
importancia_metodos_ageis:"",
classificacao_1:"Indireta",
classificacao_2:"Qualidade do produto",
classificacao_3:"Quantitativa, Subjetiva, Acompanhamento"
},{
nome:"Percentual do esforço despendido para correção de erros em relação ao esforço gasto em todo o projeto",
objetivo:"Estimar o percentual de esforço despendido para correção de falhas em relação ao esforço gasto em todo o projeto",
pergunta: "Qual o percentual de esforço despendido para correção de falhas em relação a,o esforço gasto em todo o projeto?",
base_medicao:"(Esforço gasto para correção de falhas / Esforço total do projeto) x 100",
suposicoes:"A equipe de desenvolvimento registra o tempo gasto com correção de falhas. A carga horária total do projeto é monitorada.",
tendencia_experada:"Diminuir o esforço gasto para correção de falhas.",
quando_utilizar:"Quando a equipe deseja saber o esforço para correção de falhas em relação ao esforço total gasto com o projeto",
quando_parar:"Ao finalizar o projeto",
manipulacao:"A equipe registra todo o esforço (em horas) para correção de falhas e em todo o projeto.",
cuidados:" ",
coleta:"Execução",
forma:"",
importancia_metodos_ageis:"",
classificacao_1:"Indireta",
classificacao_2:"Desempenho do processo",
classificacao_3:"Quantitativa, Objetiva, Acompanhamento"
},{
nome:"Percentual de cobertura de teste = Cobertura de teste",
objetivo:"Verificar qual o percentual de cobertura dos casos de teste",
pergunta: "Qual o percentual de cobertura de teste?",
base_medicao:"(total dos casos de teste executados /   total de casos de teste planejados) * 100%",
suposicoes:"A equipe deve planejar e executar os casos de teste e verificar o percentual de cobertura de teste.",
tendencia_experada:"Fazer a cobertura completa dos casos de teste.",
quando_utilizar:"Quando se deseja monitorar se os casos de testes planejados cobrem todo o sistema",
quando_parar:"Quando a cobertura for 100%",
manipulacao:"Através de ferramentas, gerenciamento de projetos ou observação da equipe de teste",
cuidados:" ",
coleta:"Execução",
forma:"",
importancia_metodos_ageis:"",
classificacao_1:"Indireta",
classificacao_2:"Qualidade do produto",
classificacao_3:"Quantitativa, Objetiva, Acompanhamento"
},{
nome:"Pontualidade na entrega",
objetivo:"Minimizar o atraso na entrega do sistema",
pergunta: "Qual a relação do total de encomendas em relação ao total de entregas encomendadas?",
base_medicao:"Precisão na entrega é determinada olhando para o número de entregas atrasadas em relação ao total de entregas encomendadas. (Entregas atrasadas / entregas encomendadas)",
suposicoes:"A equipe planejou o projeto e cada iteração, e conciliou com outros projetos.",
tendencia_experada:"Evitar atrasos na entrega",
quando_utilizar:"Durante todo o projeto, para evitar atrasos",
quando_parar:"Ao término do projeto",
manipulacao:"O líder do projeto deve monitorar e garantir a pontualidade da entrega (através de reuniões, planejamento, estabelecimento de prazos)",
cuidados:" ",
coleta:"Execução",
forma:"",
importancia_metodos_ageis:"",
classificacao_1:"Indireta",
classificacao_2:"Cronograma e progresso",
classificacao_3:"Qualitativa, Objetiva, Acompanhamento"
},{
nome:"Tempo de resposta do sistema",
objetivo:"Identificar o tempo de resposta do sistema a algum processo solicitado",
pergunta: "Quanto tempo o sistema demora par,a responder a um processo solicitado?",
base_medicao:"Contagem do tempo em segundos",
suposicoes:"O usuário utiliza uma ferramenta de automação de teste e o sistema demora demora para executar as solicitações.",
tendencia_experada:"O sistema deve responder com rapidez ao processo solicitado.",
quando_utilizar:"Quando se deseja medir o tempo de resposta do sistema a solicitação de um processo. Quando se deseja medir a eficacia do sistema",
quando_parar:"Quando o tempo de resposta do sistema for o esperado",
manipulacao:"É o tempo do início ao fim de um processo do sistema",
cuidados:" ",
coleta:"Execução",
forma:"",
importancia_metodos_ageis:"",
classificacao_1:"Direta",
classificacao_2:"Desempenho do processo",
classificacao_3:"Quantitativa, Objetiva, Acompanhamento"}]